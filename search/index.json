[{"content":"Python学习 基础 运算符 表达式 常量 变量 注释 输入、输出 输入输出(input/output) 1 2 3 input(\u0026#39;输入：\u0026#39;) 输入：--- print(\u0026#39;hello world!\u0026#39;) 格式化输出 1 2 3 x = 1.98739 print(\u0026#39;%.2f\u0026#39; % x) # 1.99 注意这里是四舍五入 在字符串中插入变量(f\u0026quot; \u0026ldquo;) 1 2 3 a = 123 print(f\u0026#34;hello maizi {a}\u0026#34;) # hello maizi 123 fomat() 1 2 3 4 age = 12 txt = \u0026#34;My name is John, and I am {}\u0026#34; print(txt.format(age)) # My name is John, and I am 12 注释(comment) 1 # comments 常量(constant) 变量(variable) 变量类型：其中bool类型与java不同，python中是True和False 1 2 3 4 a = 10 # int b = 23.3 # float c = \u0026#39;abc\u0026#39; # str d = False # bool 类型转换： 1 2 3 4 5 6 7 8 9 10 x = 10 int(x) # 10 float(x) # 10.0 str(x) # 10 str = \u0026#39;1A\u0026#39; print(int(str, 16)) # 26 将16进制字符串转换为十进制 str = \u0026#39;100\u0026#39; print(int(str, 8)) # 64 将8进制字符串转换为十进制 全局变量 1 global x\t1 2 3 4 5 6 7 num = 1 def inc(): num += 1 print(num) inc() # UnboundLocalError: local variable \u0026#39;num\u0026#39; referenced before assignment 第三行代码错误，也就是说，这里的num是一个局部变量，没有被初始化就自增。\n那我们如何使用呢？\n1 2 3 4 5 6 7 8 9 num = 1 def inc(): global num num += 1 print(num) inc() print(num) # 2 2 可以加上第3行代码，使用global关键字，这时候就可以改变全局变量num的值，但是不推荐这样使用，因为在函数中改变全局变量的值是不明智的，牵一发而动全身。可以使用return关键字，很好的解决这个问题。\n1 2 3 4 5 6 7 num = 1 def inc(): return num + 1 print(inc()) print(num) # 2 1 Scope 1 2 3 4 5 6 7 8 9 10 11 name = \u0026#34;maizi\u0026#34; def test(): number = 1 name = \u0026#34;xxx\u0026#34; print(name) test() print(name) print(number) # xxx maizi # error 作用域，第一行的name是全局变量， 其可以作用在其他函数中，第3行的number是局部变量，它仅仅在函数test中可以使用。离开函数的作用域后就失效。所以第9行报错。\n1 2 3 4 5 6 7 8 9 10 11 name = \u0026#34;maizi\u0026#34; def test(): def test2(): print(name) test2() test() test2() # maizi # NameError: name \u0026#39;test2\u0026#39; is not defined. Did you mean: \u0026#39;test\u0026#39;? 第9行会出错，因为test2的命名空间（namespace）在test内，和作用域一个道理。\n运算符(opetaor) 1 2 3 + - * / 加减乘除 ** 幂运算 a ** b # a的b次方 值得一提的是，Python3中的整数除法做了优化，与c和java不同，不再进行截断。\n1 2 3 4 a = 99 b = 100 c = a / b # c = 0.99 表达式(expession) 1 2 3 4 5 6 a = 1 + 2 ** 3 / 2 * 5 # a = 21.0 # 1. 2**3 = 8 # 2. 8 / 2 = 4.0 # 3. 4.0 * 5 = 20.0 # 4. 1 + 20.0 = 21.0\t优先级：\n指数 \u0026ndash;\u0026gt; 乘 除 \u0026ndash;\u0026gt; 加减 有括号的优先 从左往右 条件判断语句() if - then - else 如果条件满足则执行，意味着只执行一次。\n1 2 3 4 5 6 x = 5 if x \u0026lt; 5 : x = 9 else : x = 10 # res : 10 可以看到 执行了x=10，而没有执行x=9。因为x \u0026lt; 5不满足，执行else语句。if和else语句之后可以执行多个语句（block）。\n注意：if和else语句的结尾要有:号\nif not 如果不是则执行\n1 2 if not (bool): pass if （1） not in （2） 如果1 不在2 中则执行\n1 2 3 if letter not in word: pass # 如果字符letter不在单词word中执行 pass 空语句 当程序不需要实现功能时，使用pass语句\n缩进 插一个话题，缩进在python中的重要性远大于其它编程语言。python中的缩进是4个空格组成，而不是一个Tab键的符号，这里有一个建议，在编译器中把Tab键设置为4个空格，或者编写python程序时缩进就用4个空格代替。\nelif语句 elif是else if的缩写，当程序有多个判断条件时使用。\n1 2 3 4 5 6 7 8 if x \u0026lt; 10 : print(\u0026#34;x \u0026lt; 10\u0026#34;) elif x \u0026lt; 20 : print(\u0026#34;10 \u0026lt;= x \u0026lt; 20\u0026#34;) elif x \u0026lt; 30 : print(\u0026#34;20 \u0026lt;= x \u0026lt; 30\u0026#34;) else : print(\u0026#34;x \u0026gt;= 30\u0026#34;) elif好像划分上面条件的集合区域后，接着划分剩余的区域，else则表示最后剩余的区域。\ntry-except语句 1 2 x = input(\u0026#34;input a integer: \u0026#34;) x = int(x) 上面第二行程序有出错风险，如果输入为字符的话会发生错误。\ninput a integer: ten\rTraceback (most recent call last):\rFile \u0026quot;D:\\workspace\\python\\test\\t2.py\u0026quot;, line 2, in \u0026lt;module\u0026gt;\rx = int(x)\r^^^^^^\rValueError: invalid literal for int() with base 10: 'ten'\n那么除了让用户输入一个整数这种硬性要求之外，还能怎么办呢？ 这里就要用到try-except这种异常处理语言：\n1 2 3 4 5 x = input(\u0026#34;input a integer: \u0026#34;) try : x = int(x) except : print(\u0026#34;Error!\u0026#34;) 当try中的语句出错时会直接执行except语句，提示错误信息。有没有发现try-except语句和if-then-else很像，它也属于条件判断语句。和if-then-else语句一样，try和except下面也是块结构（block），可以有多个语句。\n1 2 3 4 5 6 7 x = input(\u0026#34;input a integer: \u0026#34;) y = input(\u0026#34;input a integer: \u0026#34;) try : x = int(x) y = int(y) except : x = -1 如果x = int(x)这一条语句出错了，那么y = int(y)就不会接着执行，而是直接执行except语句。 except语句中不仅仅可以用来返回错误信息，还可以使用其他的值来表示和处理异常情况。\n函数（function） 函数的定义 在实际编程中需要重复使用一些代码和功能，这时就需要把代码块封装起来。这种封装起来的代码块就叫函数\n函数声明 1 2 def add() : print(12 + 13) python中的函数用def关键字声明\n函数的引用 这里不用调用（call）而是引用（reference）是因为函数创建后会在内存中开辟一段空间，而程序只是进入了这段空间，而不是把这段空间拿走使用。\n1 2 3 def add(a, b) : return a + b print(add(2, 3)) 第三行print()函数中的add(2, 3)就是引用。这里的return和add(a, b)中的a、b是什么呢？我们下节讲。\n函数的返回 我们需要一个函数返回给我们一些数据，这时就要使用return关键字\n1 2 3 4 5 def puls() : return \u0026#34;hello \u0026#34; + \u0026#34;maizi\u0026#34; print(puls()) #打印hello maizi #这里涉及到字符串的拼接 函数的参数 1 2 3 4 5 x = 30 y = 20 def add(a, b) : return a + b print(add(x, y)) 来看上面的代码，x、y是实际参数，a、b是形式参数。形参的变化不会影响实参的变化，即使它们同名。例如上面的add(a, b)换成add(x, y)和实参一样但不会影响实参的值。\n1 2 3 4 5 6 7 x = 30 y = 20 def f(x, y) : x = x + 3 y = y + 4 print(x, y) # 输出结果：30 20 循环（loop） while 当条件满足时执行循环语句，否则跳出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 total = 0; count = 0; while True : a = input(\u0026#34;Enter a number: \u0026#34;) if a == \u0026#34;done\u0026#34; : break try: a = int(a) except: print(\u0026#34;Invalid input\u0026#34;) continue count += 1 total += a print(total, count, (total / count)) while语句后面跟了一个bool类型的表达式或者变量，如果为True才往下执行。上面的代码用到了break和continue语句，我们下面开始讲。\nbreak和continue break：跳出当前最近的一个循环。就是说如果多个循环嵌套的话，只跳出当前break语句所在的循环。例：\n1 2 3 4 while True : while True: if x \u0026gt; 0 : break 这条语句只跳出最内层循环。\ncontinue：跳出现在的迭代，到下一次迭代。\n1 2 3 4 5 x = 5 while x \u0026gt; 0 : if x == 1 : continue x = x - 1 当x==1时continue直接跳过当前的迭代，进行下一次迭代，x=x-1这段代码根本没有执行，所以这段代码会进入死循环。\nfor语句 1 2 3 for i in [1, 2, 3, 4, 5] : print(i) # 输出 1 2 3 4 5 当然有换行 类似java中的for-each，遍历数组中的元素。\n字符串（str） 1 2 str = \u0026#39;hello maizi\u0026#39; # 012345678910 字符串下标从0开始，单引号和双引号包裹都可以，这里我选择单引号。\n1 2 3 4 5 str = \u0026#39;hello maizi\u0026#39; a = str.find(\u0026#39;o\u0026#39;) print(a) print(str[0:4]) str[0:4]返回从下标位置0到4的字符（不包括4位置的字符）左闭右开[a, b)区间。[ : ], [ : a], [b : ]这三种语法是允许的。\n值得一提的是[ : 100]并不会引起下标越界错误。\n易错点：字符串用单引号包裹时，如果内部有 ' 号会引发错误！ 1 print(\u0026#39;people\u0026#39;s food\u0026#39;)\tSyntaxError: unterminated string literal\nfind()函数 find()函数返回\u0026rsquo;o\u0026rsquo;位置的下标。\n1 b = \u0026#39;abc\u0026#39;.find(\u0026#39;c\u0026#39;)\t这里的\u0026rsquo;abc\u0026rsquo;.find()说明字符串常量也可以直接调用方法。\n大小写转换upper() / lower() 1 2 3 4 5 str = \u0026#39;Hello Maizi\u0026#39; print(str.upper()) #HELLO MAIZI print(str.lower()) #hello maizi print(str.title()) #Hello Maizi print(str.capitalize()) #Hello maizi 删除空白 1 2 3 4 str = \u0026#39; hello python \u0026#39; print(str.rstrip()) #\u0026#39; hello python\u0026#39; print(str.lstrip()) #\u0026#39;hello python \u0026#39; print(str.strip())\t#\u0026#39;hello python\u0026#39; rstrip()删除右侧符号空白，lstrip()删除左侧空白，strip()删除两侧的空白。以上三个函数都不会删除中间的空白。\nstrip()函数也可以删除左右两侧的字符串\n1 2 string = \u0026#34;9206.hello999maizi.9206\u0026#34; print(string.strip(\u0026#39;.0123456789\u0026#39;)) translate()函数 将字符串按一定的规则翻译。\n1 string.translate(table) 注意这里的table不是传统的数据类型，而是一种翻译规则（由函数maketrans()生成）\nmaketrans()函数 1 maketrans(str1, str2, str3) str1： 需要替换的字符串 str2： 替换后的字符串，长度与str1保持一致。 str3： 需要删除的字符串 处理字符 chr() 将十进制数转换为字符\n1 2 chr(65) # \u0026#39;a\u0026#39; ocd(ordinal)\nchr(ocd(\u0026lsquo;a\u0026rsquo;) + 1)\n文件（file） 打开文件 1 fhand = open(\u0026#39;data.txt\u0026#39;) 这里的fhand是一个handle，是文件的序列而不是一个数据类型。类似java的Scanner扫描器。\n当然open()里面可以有参数。open(filename, mode, encoding)\nfilename: 文件名 mode：读写模式 \u0026lsquo;r\u0026rsquo;, \u0026lsquo;w\u0026rsquo; encoding: 编码格式 \u0026lsquo;UTF-8\u0026rsquo;等 关闭文件 close（） 1 2 fd = open(\u0026#34;data.txt\u0026#34;) fd.close() 如何关闭文件，文件句柄不会被释放（一直在占用内存）\n更好的打开文件方法 open（）函数和close（）函数之间的代码如果出现问题，close（）函数就不会执行。我们有一个更好的方法：\n1 2 3 4 5 with open(\u0026#34;data.txt\u0026#34;) as file: lines = file.readlines() for line in lines: print(line) 使用with关键字打开文件，由python自己把握关闭文件的时机。\nreadline() and readlines() 顾名思义，readline读取一行，readlines读取所有的行并存入列表中。\n文件的写入 write（） 使用write（）函数需要修改文件的读写属性\n1 2 with open(\u0026#39;data.txt\u0026#39;, \u0026#39;w\u0026#39;) as fd fd.write(\u0026#34;maizi\u0026#34;) 读写属性 \u0026lsquo;r\u0026rsquo; 只读模式（read） \u0026lsquo;w\u0026rsquo; 写入模式 (write) \u0026lsquo;a\u0026rsquo; 附件模式 (add) \u0026lsquo;r+\u0026lsquo;读写模式 (read and write) Python默认以只读模式打开文件\n如果以写入模式打开文件时要小心！写入时会先清空文件。然后才会写入，所有会清空原文件的内容。（使用前要确保原文件不用了）\nos操作 列出文件名 1 2 import os lt = os.listdir(path) getcwd() 当前的工作路径\nchdir (path) 切换工作路径\n重命名文件（rename）\n1 os.rename(file_name, new_neme) 清屏clear\n1 os.system(\u0026#34;clear\u0026#34;) 例题：修改prank文件夹下的所有文件名 1 2 3 4 5 6 7 8 9 10 11 12 13 import os def rename_file(): # list filename lt = os.listdir(\u0026#39;C:\\ITPG\\part04\\prank\u0026#39;) print(lt) table = str.maketrans(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;0123456789\u0026#39;) #翻译表 os.chdir(\u0026#39;C:\\ITPG\\part04\\prank\u0026#39;) # rename file for file_name in lt: os.rename(file_name, file_name.translate(table)) rename_file() 列表（list） list类似于其他语言的数组，但是更像java中的ArrayList。list可以有多种类型的元素。\n1 2 3 4 5 6 a = [1, 2, 3, 4, 5] b = [9, \u0026#39;b\u0026#39;, \u0026#39;tom\u0026#39;, \u0026#39;jack\u0026#39;] print(a[3]) # 4 print(a[1:3]) #[2, 3] print(a[:]) #[1, 2, 3, 4, 5] print(a[1:100]) #[2, 3, 4, 5] 列表的下标（index）也是从0开始的，a[1, 100]并不会引发下标错误（这一点和str类似）\n1 2 list = [1, 3, [2, 5], 3] print(len(list)) 注意：这里输出的是4 ，而不是5。这说明了什么呢？这里的[2, 5]被当做是单个元素（它是一个由两个元素组成的列表）。\n列表中添加元素（append()） 1 2 list = [1, 32, 42, 58, 72] list.append(-2) 例题：如何求列表中的元素平均值\n方法一：\n1 2 3 4 5 6 7 8 9 list = [1, 32, 42, 58, 72] total = 0 sum = 0 for i in list: sum += i total += 1 print(\u0026#39;avg:\u0026#39;, (sum / total)) 用for - in遍历数组中的元素。用sum累加元素，total记录元素的个数，sum / total 就是其平均值（print()中的,号会使输出用空格隔开）。\n方法二：\n1 2 3 list = [1, 32, 42, 58, 72] print(\u0026#39;avg:\u0026#39;, sum(list) / len(list)) #输出： avg: 41.0 方法二显然更简洁，这里用到了sum()和len()函数，但是如果数据量很大且事先没有list时，会有很大的内存开销（毕竟多了list）。\nlist的其他操作 remove(argument) 这里的argument是list里的值（不要把它当成是下标了）。 1 2 3 4 list = [1, 3, 5, 7, 9] list. remove(3) print(list) # [1, 5, 7, 9] list.remove(2) # ValueError: list.remove(x): x not in list join（）合并列表中的元素 一般用于合并列表中的char和str类型的元素\n函数原型 str.join(list) 其中str表示合并时用str类型的变量当连接符、list是列表中的元素。\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; char_list = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(char_list) \u0026gt;\u0026gt;\u0026gt; \u0026#39;123\u0026#39; \u0026gt;\u0026gt;\u0026gt; str_list = [\u0026#39;maizi\u0026#39;, \u0026#39;xiaobei\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39; \u0026#39;.join(str_list) \u0026gt;\u0026gt;\u0026gt; \u0026#39;maizi xiaobei\u0026#39; random.choice(list) 随机选择list中的一个元素 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; word = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.choice(word) \u0026#39;a\u0026#39; 集合（set） 集合和数学上的集合类似，没有重复元素，且没有顺序之分。\n集合的定义 1 fruits = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} 集合的增删改查 1 2 3 add(element) 添加一个元素 remove(element) 删除一个元素 update(set) 增加一个集合 字典（dictionary） 字典是key-value键值对。类似java中的HashMap\u0026lt;key, value\u0026gt;，字典中的元素不保证按照输入的顺序排列。\n1 2 3 4 5 6 7 8 9 10 di = { \u0026#39;jack\u0026#39; : 20, \u0026#39;tom\u0026#39; : \u0026#39;32\u0026#39;, \u0026#39;anny\u0026#39; : 29, 12 : 99, 73 : \u0026#39;hlp\u0026#39; } print(di) } # {\u0026#39;jack\u0026#39;: 20, \u0026#39;tom\u0026#39;: \u0026#39;32\u0026#39;, \u0026#39;anny\u0026#39;: 29, 12: 99, 73: \u0026#39;hlp\u0026#39;} 如上所示，字典的key和value可以是任意数据类型。\n在字典中添加键值对 1 2 3 b = dict() b[\u0026#39;hes\u0026#39;] = 38 b[\u0026#39;hh\u0026#39;] = \u0026#39;ww\u0026#39; 删除键值对 del关键字删除键值对（delete）\n1 2 3 a = {\u0026#39;k\u0026#39; : 3, \u0026#39;h\u0026#39; : 4} del a[\u0026#39;k\u0026#39;] print(a) # {\u0026#39;h\u0026#39;: 4} 遍历字典 遍历value 1 2 3 4 5 6 7 8 9 10 yyy = { \u0026#39;h\u0026#39; : 3, \u0026#39;w\u0026#39; : 2, \u0026#34;y\u0026#34; : 1 } for i in yyy.values(): print(i) # 3 # 2 # 1 遍历key 1 2 for s in yyy.keys(): print(s) 这里的keys（）和value（）不只是用来遍历，它们其实产生一个列表。\n按特定顺序遍历字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 yyy = { \u0026#39;jen\u0026#39; : 8, \u0026#39;sarah\u0026#39; : 5, \u0026#39;edward\u0026#39; : 1, \u0026#39;phil\u0026#39; : 12 } for name in sorted(yyy.keys()): print(name) # edward jen phil sarah for num in sorted(yyy.values()): print(num) # 1 5 8 12 # 当然是有换行的， 为了方便以后例题的输出不必换行。 get()函数 用[ ]来获取字典的值，如果遇到空的话就会出错，用get可以很好的解决这个问题。get(key)函数输出key获取value，没找到返回None。\n1 2 3 4 5 a = {\u0026#39;k\u0026#39; : 3, \u0026#39;h\u0026#39; : 4} c = a.get(\u0026#39;k\u0026#39;) print(c) # 3 d = a.get(\u0026#39;es\u0026#39;) print(d) # None 列表中嵌套字典 1 2 3 4 5 6 7 8 9 10 11 12 travel_log = [ { \u0026#34;Country\u0026#34;: \u0026#34;France\u0026#34;, \u0026#34;cities_visited\u0026#34;: [\u0026#34;Paris\u0026#34;, \u0026#34;Lille\u0026#34;, \u0026#34;Dijon\u0026#34;], \u0026#34;total_visits\u0026#34;: 12 }, { \u0026#34;Country\u0026#34;: \u0026#34;Germany\u0026#34;, \u0026#34;cities_visited\u0026#34;: [\u0026#34;Berlin\u0026#34;, \u0026#34;Hamburg\u0026#34;, \u0026#34;Stuttgart\u0026#34;], \u0026#34;total_visits\u0026#34;: 5 } ] 注意上面的【】不能换成{}，这样也解释不同\n字典中嵌套字典 1 \u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;maizi\u0026#39;: {\u0026#39;age\u0026#39;: 22}} 字典与函数搭配使用 当需要实现的功能太多时， 其他语言会使用switch分支结构，或者使用一堆的if-then-eles语句。\n在python中可以将字典和函数搭配起来来实现这个功能\n1 2 3 4 5 6 operations = { \u0026#39;+\u0026#39;: add, \u0026#39;-\u0026#39;: sub, \u0026#39;*\u0026#39;: mul, \u0026#39;/\u0026#39;: div } 那么该怎么调用函数呢？\n1 operations[\u0026#34;+\u0026#34;](n1, n2) 其中cal[\u0026quot;+\u0026quot;]定位到函数的位置，（n1，n2）可以进行传参。上面的代码可能看不到和其他方式的相比的优势。\n可以看小项目3\n例题1：统计列表中的单词个数 1 2 3 4 5 6 7 8 9 10 11 lists = [\u0026#39;jack\u0026#39;, \u0026#39;bob\u0026#39;, \u0026#39;anny\u0026#39;, \u0026#39;jack\u0026#39;, \u0026#39;bob\u0026#39;, \u0026#39;jack\u0026#39;, \u0026#39;ddd\u0026#39;] cnts = dict() for word in lists: if word not in cnts: cnts[word] = 1 else: cnts[word] += 1 print(cnts) # {\u0026#39;jack\u0026#39;: 3, \u0026#39;bob\u0026#39;: 2, \u0026#39;anny\u0026#39;: 1, \u0026#39;ddd\u0026#39;: 1} 上面代码的5~8行可以简化为一行代码：\n1 cnts[word] = cnts.get(word, 0) + 1 字典里的get(self, default)找到用key值self找到键值对的value，如果没找到就赋值default。\n例题2：统计Tante Million中出现次数最多的单词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fhand = open(\u0026#39;Tante_Million.txt\u0026#39; ,encoding =\u0026#39;utf-8\u0026#39;) cnts = dict() for line in fhand: words = line.split() for word in words: cnts[word] = cnts.get(word, 0) + 1 maxValue = -1 for i in cnts: if maxValue \u0026lt; cnts[i]: maxValue = cnts[i] maxWord = i print(i, maxValue) # eBooks. 1808 元组() 列表非常适用于存储在程序运行期间可能变化的数据集。然而你有时候需要创建不可修改的元素，元组可以满足这种需求。Python将不能修改的值称为不可变的，而不可变的列表被称为元组。\n看下面程序：\n1 2 3 4 5 6 7 8 tup = (20, 40) print(tup) # (20, 40) print(tup[1]) # (40) tup[0] = 30 print(tup) # TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment 看上面的代码，我们可以得到如下信息：\n元组用（）包裹 元组也是从下标0位置开始的 元组内的元素不可以更改 注意：严格的说，元组是由逗号标识的，圆括号只是为了让元组看起来更整洁、更清晰。\n我们也可以用for循环遍历元组。\n1 2 3 4 5 6 ttt = (20, 40, 50) for i in ttt: print(i) # 20 # 30 # 50 修改元组变量 虽然不能修改元组中的元素，但是可以对元组重新赋值。\n1 2 3 ttt = (20, 40) ttt = (50, 100) 类(class) python的类和其他语言一样，只是语法比较简洁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year def get_name(self): long_name = f\u0026#34;{self.year} {self.make} {self.model} \u0026#34; return long_name.title() c = Car(\u0026#34;audi\u0026#34;, \u0026#39;a4\u0026#39;, 2019) print(c.get_name()) # 2019 audi a4 #_init_函数相当于其他语言的构造函数，其用于给对象（实例）赋值。 self用于在类中访问其他所有成员变量，相当于java语言中的this。\n导入类 方法： 方法一 ： import (class name) 方法二 ：from （包名或者.py文件名（不包含.py））import（class name） 注：from 包名 import （方法甚至是变量）\nas关键字： from (包名或者.py文件) import (class name) as (new name)\n继承 子类继承父类中的所有方法和属性。\n1 2 3 4 5 6 7 8 9 10 11 class Parent: def __init__(self, last_name, eye_color): self.last_name = last_name self.eye_color = eye_color class Child(Parent): def __init__(self, last_name, eye_color, age): super().__init__(last_name, eye_color) # 上面一行也可以用 # Parent.__init__(self, name, age) self.age = age 构造方法 1 2 方法名：__init__ 用途：用于类的初始化 self 类中所有方法都必须有self参数，它可以调用类中的所有参数。\nsuper()方法 super（）方法可以调用父类中的所有东西。\n插叙 python中的列表、字典、元组的表示差别：\n1 2 3 lists = [1, 2, 3, 4, 5] dicts = {\u0026#39;java\u0026#39; : 1, \u0026#39;python\u0026#39; : 2, \u0026#39;c++\u0026#39; : 3} tups = (a, b) 三者使用不同的括号。\n一个例题 牛牛和牛妹一起玩密码游戏，牛牛作为发送方会发送一个4位数的整数给牛妹，牛妹接收后将对密码进行破解。\n破解方案如下：每位数字都要加上3再除以9的余数代替该位数字，然后将第1位和第3位数字交换，第2位和第4位数字交换。\n请输出牛妹破解后的密码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 n = input() lst = [] for i in [0, 1, 2, 3]: # range(len(n))可以代替[0, 1, 2, 3] tmp = ((int(n[i]) + 3) % 9) lst.append(tmp) #交换list元素中的值 def swap(list, i, j): tmp = list[i] list[i] = list[j] list[j] = tmp # 交换1,3 2，4位置 swap(lst, 0, 2) swap(lst, 1, 3) for i in lst: print(i , end=\u0026#34;\u0026#34;) swap()函数和其他语言简直一模一样。\n保留小数 rount（float）四舍五入到整数\nrount（float，index）四舍五入到第index位\nmath.ceil(float) 向上取整（整数）\n打开一个网址 1 2 import webbrowser webbrowser.open(\u0026#34;www.whhcrj.cn\u0026#34;)\t延时函数 1 2 3 4 5 import time time.sleep(5)#延时5s # ctime() print(time.ctime()) # Sun Apr 9 15:13:29 2023 json存储数据 json格式文件来源于JavaScript，用于存储数据\ndump()方法 方法原型 dump(data, json object)\n该方法有两个参数，第一个参数是写入的数据，第二个参数是写入的json文件对象。\n1 2 3 4 5 6 7 import json filename = \u0026#34;jdata.json\u0026#34; string = \u0026#39;maizi\u0026#39; with open(filename, \u0026#39;w\u0026#39;) as f: json.dump(string, f) load（）方法 方法原型load（json object）\n接受一个文件句柄参数类型（fd），返回json数据。\n1 2 with open(filename) as f: value = json.load(f) 小项目 项目1: 编写一个简单的译码、解码的小项目 要求：\n有logo 输入一个字符串，把字符串中除了数字以外的字符都加密 加密方式：向后移动shift位 其他细节优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from art import logo # display logo print(logo) alphabet = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;] direction = input(\u0026#34;Type \u0026#39;encode\u0026#39; to encypt, type \u0026#39;decode\u0026#39; to decrypt:\\n\u0026#34;) text = input(\u0026#34;Type your message:\\n\u0026#34;).lower() shift = int(input(\u0026#34;Type the shift number:\\n\u0026#34;)) new_text = text.split(\u0026#39; \u0026#39;) def caesar(start_text, plain_text, shift_amount): if start_text == \u0026#39;decode\u0026#39;: shift_amount = -shift_amount new_string = \u0026#34;\u0026#34; for word in plain_text: if not word.isdigit(): # 关键代码 for letter in word: position = alphabet.index(letter) new_position = (position + shift_amount) % 26 new_string += alphabet[new_position] else: new_string += word new_string += \u0026#34; \u0026#34; print(f\u0026#34;you answer is {new_string}\u0026#34;) caesar(direction, new_text, shift) # main 写的有点冗余（可以用一个while循环解决） start = input(\u0026#34;Type \u0026#39;yes\u0026#39; if you want to go again, Otherwise type \u0026#39;no\u0026#39;.\u0026#34;) if start == \u0026#39;yes\u0026#39;: direction = input(\u0026#34;Type \u0026#39;encode\u0026#39; to encypt, type \u0026#39;decode\u0026#39; to decrypt:\\n\u0026#34;) text = input(\u0026#34;Type your message:\\n\u0026#34;).lower() next_text = text.split(\u0026#39; \u0026#39;) shift = int(input(\u0026#34;Type the shift number:\\n\u0026#34;)) caesar(direction, next_text, shift) 项目2：简单的拍卖系统 输入姓名和出价，选出出价最高的人。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import os from art import logo print(logo) print(\u0026#34;Welcome to the secret auction program.\u0026#34;) flag = True dic = {} while flag: name = input(\u0026#34;What is your name?: \u0026#34;) bid = int(input(\u0026#34;What\u0026#39;s your bid?: ￥\u0026#34;)) dic[name] = bid text = input(\u0026#34;Are there any other bidders? Type \u0026#39;yes\u0026#39; or \u0026#39;no\u0026#39;.\\n\u0026#34;) if text == \u0026#39;yes\u0026#39;: os.system(\u0026#34;clear\u0026#34;) else: flag = False print(dic) ans = 0 for i in dic: if dic[i] \u0026gt; ans: ans = dic[i] winner_name = i print(f\u0026#34;The winner is {winner_name} with a bid of ￥{ans}\u0026#34;) 项目3：简易计算器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # logo logo = \u0026#34;\u0026#34;\u0026#34; _____________________ | _________________ | | | Pythonista 0. | | .----------------. .----------------. .----------------. .----------------. | |_________________| | | .--------------. || .--------------. || .--------------. || .--------------. | | ___ ___ ___ ___ | | | ______ | || | __ | || | _____ | || | ______ | | | | 7 | 8 | 9 | | + | | | | .\u0026#39; ___ | | || | / \\ | || | |_ _| | || | .\u0026#39; ___ | | | | |___|___|___| |___| | | | / .\u0026#39; \\_| | || | / /\\ \\ | || | | | | || | / .\u0026#39; \\_| | | | | 4 | 5 | 6 | | - | | | | | | | || | / ____ \\ | || | | | _ | || | | | | | | |___|___|___| |___| | | | \\ `.___.\u0026#39;\\ | || | _/ / \\ \\_ | || | _| |__/ | | || | \\ `.___.\u0026#39;\\ | | | | 1 | 2 | 3 | | x | | | | `._____.\u0026#39; | || ||____| |____|| || | |________| | || | `._____.\u0026#39; | | | |___|___|___| |___| | | | | || | | || | | || | | | | | . | 0 | = | | / | | | \u0026#39;--------------\u0026#39; || \u0026#39;--------------\u0026#39; || \u0026#39;--------------\u0026#39; || \u0026#39;--------------\u0026#39; | | |___|___|___| |___| | \u0026#39;----------------\u0026#39; \u0026#39;----------------\u0026#39; \u0026#39;----------------\u0026#39; \u0026#39;----------------\u0026#39; |_____________________| \u0026#34;\u0026#34;\u0026#34; # Add def add(n1, n2): return n1 + n2 # Subract def sub(n1, n2): return n1 - n2 # Multipy def mul(n1, n2): return n1 * n2 # Divide def div(n1, n2): return n1 / n2 operations = { \u0026#39;+\u0026#39;: add, \u0026#39;-\u0026#39;: sub, \u0026#39;*\u0026#39;: mul, \u0026#39;/\u0026#39;: div } def calculator(): print(logo) n1 = float(input(\u0026#34;Enter a first number: \u0026#34;)) for i in operations: print(i, end=\u0026#34; \u0026#34;) print() flag = True while flag: oper = input(\u0026#34;Entet the operation: \u0026#34;) n2 = float(input(\u0026#34;Enter the next number: \u0026#34;)) # 在字典中找到函数 ans = operations[oper](n1, n2) print(f\u0026#34;{n1} {oper} {n2} = {ans}\u0026#34;) text = input(f\u0026#34;Type \u0026#39;y\u0026#39; to continue calcuating with {ans}, or type \u0026#39;n\u0026#39; to exit.: \u0026#34;) if text == \u0026#39;y\u0026#39;:\tn1 = ans elif text == \u0026#39;n\u0026#39;: flag = False calculator() calculator() 项目4：21点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 import random import os #Hint 4: Create a deal_card() function that uses the List below to *return* a random card. #11 is the Ace. def deal_card(): cards = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10] return random.choice(cards) #Hint 6: Create a function called calculate_score() that takes a List of cards as input #and returns the score. #Look up the sum() function to help you do this. def calculate_score(cur_cards): score = sum(cur_cards) #Hint 7: Inside calculate_score() check for a blackjack (a hand with only 2 cards: ace + 10) and return 0 instead of the actual score. 0 will represent a blackjack in our game. if score == 21 and len(cur_cards) == 2: return 0 #Hint 8: Inside calculate_score() check for an 11 (ace). If the score is already over 21, remove the 11 and replace it with a 1. You might need to look up append() and remove(). if 11 in cur_cards and score \u0026gt; 21: cur_cards.remove(11) cur_cards.append(1) return score #Hint 13: Create a function called compare() and pass in the user_score and computer_score. If the computer and user both have the same score, then it\u0026#39;s a draw. If the computer has a blackjack (0), then the user loses. If the user has a blackjack (0), then the user wins. If the user_score is over 21, then the user loses. If the computer_score is over 21, then the computer loses. If none of the above, then the player with the highest score wins. def compare(user_score, computer_score): if user_score == computer_score: return \u0026#34;Draw 🦐\u0026#34; elif computer_score == 0: return \u0026#34;Lose, opponent has Blackjack ℹ\u0026#34; elif user_score == 0: return \u0026#34;Win with a Blackjace 🉑\u0026#34; elif user_score \u0026gt; 21: return \u0026#34;You went over. You lose 😎\u0026#34; elif computer_score \u0026gt; 21: return \u0026#34;Opponent went over. You win 🉑\u0026#34; elif user_score \u0026gt; computer_score: return \u0026#34;You win 🉑\u0026#34; else: return \u0026#34;You lose 😎\u0026#34; #Hint 11: The score will need to be rechecked with every new card drawn and the checks in Hint 9 need to be repeated until the game ends. #Hint 9: Call calculate_score(). If the computer or the user has a blackjack (0) or if the user\u0026#39;s score is over 21, then the game ends. def play_game(): #Hint 5: Deal the user and computer 2 cards each using deal_card() and append(). user_cards = [] computer_cards = [] # init hand for _ in range(2): user_cards.append(deal_card()) computer_cards.append(deal_card()) is_game_over = False while not is_game_over: user_score = calculate_score(user_cards) computer_score = calculate_score(computer_cards) print(f\u0026#34; Your cards: {user_cards}, current score: {user_score}\u0026#34;) print(f\u0026#34; Computer\u0026#39;s first cards: {computer_cards[0]}\u0026#34;) if user_score \u0026gt; 21 or user_score == 0 or computer_score == 0: is_game_over = True else: #Hint 10: If the game has not ended, ask the user if they want to draw another card. If yes, then use the deal_card() function to add another card to the user_cards List. If no, then the game has ended. user_should_deal = input(\u0026#34;Type \u0026#39;y\u0026#39; to get another card, type \u0026#39;n\u0026#39; to pass: \u0026#34;) if user_should_deal == \u0026#39;y\u0026#39;: user_cards.append(deal_card()) else: is_game_over = True #Hint 12: Once the user is done, it\u0026#39;s time to let the computer play. The computer should keep drawing cards as long as it has a score less than 17. while computer_score != 0 and computer_score \u0026lt; 17: computer_cards.append(deal_card()) computer_score = calculate_score(computer_cards) print(f\u0026#34; Your final hand: {user_cards}, final score: {user_score}\u0026#34;) print(f\u0026#34; Computer final hand: {computer_cards}, final score: {computer_score}\u0026#34;) print(compare(user_score, computer_score)) #Hint 14: Ask the user if they want to restart the game. If they answer yes, clear the console and start a new game of blackjack and show the logo from art.py. if input(\u0026#34;D \u0026#39;y\u0026#39; to get another card, type \u0026#39;n\u0026#39; to pass: \u0026#34;) == \u0026#34;y\u0026#34;: play_game() else: os.system(\u0026#34;clear\u0026#34;) print(\u0026#34;game over!\u0026#34;) # user first card 番外： 如何在stackoverflow上提问？ How do I list all files of a directory?\n如何列出一个目录下的所有文件\n","date":"2023-10-27T20:15:16+08:00","permalink":"https://www.whhcrj.cn/p/python/","title":"Python"},{"content":"Java 杂谈 int 和Integer的联系和区别： int 是基础类型， Integer是封装类型；Integer是一个封装类，其对象可以调用类中的方法。 两个Integer对象比较时用“==”可能会发生问题 1 2 3 4 5 6 7 8 Integer a1 = 1231; Integer a2 = 1231; Integer a3 = 120; Integer a4 = 120; System.out.println(a1 == a2); //false System.out.println(a3 == a4); //true (-128 ~ 127)一个字节的缓存内用“==”也对 System.out.println(a1.equals(a2)); //true 所以对象之间的比较用equals方法比较好。对于Integer和int之间的比较均可\n1 2 3 4 5 6 int b1 = 1231; int b3 = 120; System.out.println(b1 == a1); //true System.out.println(b3 == a3); //true System.out.println(a1.equals(b1)); //true System.out.println(a1.equals(b3)); //false 字符串String类 String类是final类型；不可更改数值 1 public final class String implements Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence{} split(String str)方法\n1 2 3 4 5 6 String str = \u0026#34;aa bb ccc d\u0026#34;; String[] pic = str.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; pic.length; i++) { System.out.print(pic[i] + \u0026#34; \u0026#34;); } //输出：aa bb ccc d contains(String str)方法\n判断字符串是否包含str\nJava ArrayList 对象创建： 1 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 方法： add(value) 从列表末尾添加一个元素\nadd（index，value）在指定位置插入元素，后面元素后移\nset(index, value) 在下表为index处，修改元素值\ntoString() 转换为字符串形式\nindexOf(value) 返回值为value的元素下表，没找到返回-1\nclear() 清空列表中的元素\nisEmpty() 判断列表是否为空\nget(index) 得到下标为index位置的元素\nfoeach()\n1 2 3 4 5 6 7 8 9 10 11 12 13 ArrayList\u0026lt;Integer\u0026gt; num1 = new ArrayList\u0026lt;\u0026gt;(); num1.add(1);//0 num1.add(2);//1 num1.add(3);//2 num1.add(4);//3 num1.add(5);//4 num1.forEach(num -\u0026gt; { num1.set(num1.indexOf(num), num * 10); } ); System.out.println(num1.toString()); 输出：[10, 20, 30, 40, 50] clone() 克隆列表 1 2 ArrayList\u0026lt;Integer\u0026gt; num2 = new ArrayList\u0026lt;\u0026gt;(); num2 = (ArrayList\u0026lt;Integer\u0026gt;) num1.clone(); 10.contains(value) 查看是否包括元素\n1 2 3 4 public boolean contains(Object o) { return indexOf(o) \u0026gt;= 0; } //此处调用了indexOf()方法。 Scanner 类中的方法 方法列举 nextInt():读取一个整数\nnextLine（）：读取一行字符\nnextLong（）：读取一个长整型数\nnext() 和 nextLine()的区别？ ​\tnextLine（）读取一整行字符\n​\tnext（）把一行字符按空格分开，读取一个字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Scanner in = new Scanner(System.in); while (true) { String str = in.next(); if(str.equals(\u0026#34;end\u0026#34;)) { System.out.println(\u0026#34;in the end\u0026#34;); break; } System.out.println(str); } // 输入 hello world ! end // 输出 hello world ! in the end ArrayList\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); while (true) { String str = in.nextLine(); if(str.equals(\u0026#34;end\u0026#34;)) { System.out.println(\u0026#34;in the end\u0026#34;); break; } strings.add(str); } System.out.println(strings.toString()); //输入 hello world //输入 ni hao //输入 end //输出 in the end [hello world, ni hao] hasNext() 和 hasNextLine() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ArrayList\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); while (!in.hasNext(\u0026#34;exit\u0026#34;)) { String str = in.next(); strings.add(str); }\tSystem.out.println(strings.toString()); // 输入1\t| 2 he he she exit\tshe\texit // 输出1\t| [he, she]\t[he, she] 说明：\nhasNext（）和 hasNextLine( ) ：有字符返回true，否则返回false。 两者的区别在于是否用用空格分隔单行。 hasNextInt() 和 hasNextLong()同理，只不过是输入对象不同。 Path类 此处用的是文件的路径而不是名字\n1 2 3 4 5 6 7 8 9 String filename = \u0026#34;C:\\\\Users\\\\21060\\\\Desktop\\\\file.txt\u0026#34;; Path path = Paths.get(filename); Scanner scanner = new Scanner(path); while(scanner.hasNextLine()){ //process each line String line = scanner.nextLine(); System.out.println(line); } scanner.close(); ","date":"2023-10-19T11:23:46+08:00","image":"https://www.whhcrj.cn/p/first/people_hu3909142d87821682d03adc28d1059ae8_5445906_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.whhcrj.cn/p/first/","title":"First"}]